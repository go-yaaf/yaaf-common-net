package web

import (
	"encoding/json"
	"fmt"
	"net"
	"net/url"
	"strconv"
	"sync"
	"time"

	. "github.com/go-yaaf/yaaf-common/logger"
	"github.com/go-yaaf/yaaf-common/utils"
	"github.com/gorilla/websocket"
)

const (
	defaultReadWriteBufferSize = 8 * 1024
	maxMessageSize             = 1024 * 1024 * 5
)

type onMessageReceivedCb func(IWSClient, IWSMessage, int)
type onDisconnectedCb func(IWSClient)
type onConnectedCb func(IWSClient)

// region Web Socket client structure and fluent API configuration -----------------------------------------------------

// WSClient represent single web socket client handler
type WSClient struct {
	id                string                   // Web socket client unique ID
	uri               string                   // Web socket client URI
	queryParams       map[string]string        // URI query parameters map
	decoder           IMessageDecoder          // Message decoder
	onMessageReceived onMessageReceivedCb      // Hook to message received callback
	onDisconnected    onDisconnectedCb         // Hook for socket disconnected callback
	onConnected       onConnectedCb            // Hook for socket connected callback
	onPongReceived    PongReceivedCb           // Hook for PONG message callback
	handlers          map[int]WSMessageHandler // Map of op-code to message handler
	pingPongEnabled   bool                     // Enable PING-PONG
	closed            bool
	closeGuard        sync.RWMutex
	wcg               chan bool
	conn              *websocket.Conn // Pointer to the underlying web socket connection
}

type WSClientConfig struct {
	Id              string
	WsConn          *websocket.Conn
	OnMsgRvd        onMessageReceivedCb
	OnDisconnected  onDisconnectedCb
	OnConnected     onConnectedCb
	MessageDecoder  IMessageDecoder
	PingPongEnabled bool
	QueryParams     map[string]string
	Handlers        map[int]WSMessageHandler
}

func NewWsClient(cfg WSClientConfig) IWSClient {

	ws := &WSClient{
		conn:              cfg.WsConn,
		onMessageReceived: cfg.OnMsgRvd,
		onDisconnected:    cfg.OnDisconnected,
		onConnected:       cfg.OnConnected,
		id:                cfg.Id,
		decoder:           cfg.MessageDecoder,
		pingPongEnabled:   cfg.PingPongEnabled,
		queryParams:       cfg.QueryParams,
		closed:            false,
		wcg:               make(chan bool, 1),
		handlers:          cfg.Handlers}

	if cfg.MessageDecoder == nil {
		ws.decoder = NewJsonDecoder()
	}

	if ws.conn != nil {
		ws.run()
	}
	return ws
}

func (c *WSClient) ID() string {
	return c.id
}

func (c *WSClient) QueryParams() map[string]string {
	if c.queryParams == nil {
		c.queryParams = make(map[string]string)
	}
	return c.queryParams
}

func (c *WSClient) PongReceivedHandler(cb PongReceivedCb) {
	c.onPongReceived = cb
}

func (c *WSClient) Send(r IWSMessage) error {

	var (
		err    error
		buffer []byte
	)

	<-c.wcg
	defer func() {
		c.wcg <- true
	}()

	defer utils.RecoverAll(func(err interface{}) {
		Error("%s WSClient::writeResponse panic: %s", c.id, err)
	})

	if c.isClosed() {
		Debug("%s closed, response discarded", c.id)
		return nil
	}

	deadLine := time.Now().Add(time.Second * time.Duration(60))
	if r.MessageCode() == WsPingOpCode {

		err := c.conn.WriteControl(websocket.PingMessage, []byte(fmt.Sprintf("%d", time.Now().UnixNano()/int64(time.Millisecond))), deadLine)
		if err != nil {
			Error("[%s] error sending ping\n%s", c.id, err)
		}
		return err
	}

	if buffer, err = json.Marshal(r); err == nil {
		_ = c.conn.SetWriteDeadline(deadLine)
		if err = c.conn.WriteMessage(websocket.BinaryMessage, buffer); err != nil {
			Error("[%s] Send to client\n%s", c.id, err)
		}
	} else {
		Error("[%s] error marshalling message when trying to send\n%s", c.id, err)
	}
	return err
}

func (c *WSClient) SendRaw(buffer []byte) error {

	var (
		err error
	)

	<-c.wcg
	defer func() {
		c.wcg <- true
	}()

	defer utils.RecoverAll(func(err interface{}) {
		Error("%s WSClient::writeResponse panic: %s", c.id, err)
	})

	if c.isClosed() {
		Debug("%s closed, response discarded", c.id)
		return nil
	}

	deadLine := time.Now().Add(time.Second * time.Duration(60))
	_ = c.conn.SetWriteDeadline(deadLine)
	if err = c.conn.WriteMessage(websocket.BinaryMessage, buffer); err != nil {
		Error("[%s] error send to client %s", c.id, err)
	}
	return err
}

func (c *WSClient) ConnectUrl(url string) (err error) {
	return c.Connect(WSConnectParams{Url: url})
}

func (c *WSClient) Connect(p WSConnectParams) (err error) {

	if c.conn != nil {
		return fmt.Errorf("try to connect an already connected client")
	}

	wsUrl := p.Url

	// If Url parameter is provided use it, otherwise use port and host
	if len(wsUrl) == 0 {
		u := url.URL{Scheme: "ws", Host: p.Host, Path: p.Path}
		wsUrl = u.String()
	}

	dialer := websocket.DefaultDialer
	dialer.EnableCompression = p.CompressionEnabled

	if p.ReadBufferSize == 0 {
		dialer.ReadBufferSize = defaultReadWriteBufferSize
	} else {
		dialer.ReadBufferSize = p.ReadBufferSize
	}

	if p.WriteBufferSize == 0 {
		dialer.WriteBufferSize = defaultReadWriteBufferSize
	} else {
		dialer.WriteBufferSize = p.WriteBufferSize
	}

	if c.conn, _, err = dialer.Dial(wsUrl, p.Header); err == nil {
		c.conn.EnableWriteCompression(p.CompressionEnabled)
		if tcpConn, ok := c.conn.NetConn().(*net.TCPConn); ok {
			_ = tcpConn.SetWriteBuffer(1048576)
			_ = tcpConn.SetReadBuffer(1048576)
		}
		c.run()
		if c.onConnected != nil {
			c.onConnected(c)
		}
		c.closed = false
	}
	return err
}

func (c *WSClient) Close() error {
	c.closeConn()
	return nil
}

func (c *WSClient) RemoteAddress() (ra string) {
	if c.conn != nil {
		ra = c.conn.RemoteAddr().String()
	}
	return
}

func (c *WSClient) readPump() {
	defer utils.RecoverAll(func(err interface{}) {
		Error("WSClient::readPump error: %s", err)
	})

	c.conn.SetReadLimit(maxMessageSize)

	if c.pingPongEnabled {
		_ = c.conn.SetReadDeadline(time.Now().Add(time.Second * time.Duration(10)))
		go c.pingPong()
	} else {
		_ = c.conn.SetReadDeadline(time.Time{})
	}

	for {
		if msgType, rawMessage, err := c.conn.ReadMessage(); err != nil {
			Debug("[%s] READ Client: %s. last message(or part of it: %s)", c.ID(), err, string(rawMessage))
			continue
		} else {
			Debug("received  message type: %d from %s:\n%s", msgType, c.ID(), string(rawMessage))

			if msg, fe := c.decoder.Decode(rawMessage); fe != nil {
				Error("error decoding received message from: [%s]: error: %s message dump: %s", c.id, fe.Error(), string(rawMessage))
			} else {
				go c.handleMessageReceived(msg, len(rawMessage))
			}
		}
	}
	c.closeConn()
}

func (c *WSClient) pingPong() {
	pingTicker := time.NewTicker(3 * time.Second)
	for !c.isClosed() {
		select {
		case <-pingTicker.C:
			_ = c.Send(NewWsPingMessage())
		}
	}
	pingTicker.Stop()
}

func (c *WSClient) run() {
	c.wcg <- true
	if c.pingPongEnabled {
		c.conn.SetPongHandler(func(s string) error {
			ts, _ := strconv.ParseInt(s, 10, 64)
			tsNow := time.Now().UnixNano() / int64(time.Millisecond)
			latencyMs := tsNow - ts
			_ = c.conn.SetReadDeadline(time.Now().Add(time.Second * time.Duration(5)))
			if c.onPongReceived != nil {
				go c.onPongReceived(c.id, s, latencyMs)
			}
			return nil
		})
	}
	go c.readPump()
}

func (c *WSClient) closeConn() {

	if c.isClosed() {
		return
	}

	c.setIsClosed()

	Debug("%s closeConn invoked", c.id)

	if err := c.conn.Close(); err != nil {
		Error("%s error when closing:\n%s", err)
	}

	if c.onDisconnected != nil {
		c.onDisconnected(c)
	}

	c.onDisconnected = nil
	c.onMessageReceived = nil
	c.onPongReceived = nil
}

func (c *WSClient) isClosed() (v bool) {
	c.closeGuard.Lock()
	defer c.closeGuard.Unlock()

	v = c.closed
	return
}

func (c *WSClient) setIsClosed() (v bool) {
	c.closeGuard.Lock()
	defer c.closeGuard.Unlock()

	c.closed = true
	return
}

// if onMessageReceived callback provided, invoke it
func (c *WSClient) handleMessageReceived(m IWSMessage, sizeInBytes int) {

	invokeHandlerWrapper := func(handler WSMessageHandler) {
		start := time.Now()

		defer func() {
			timeSpentInHandler := time.Since(start).Seconds()
			if timeSpentInHandler > 3.0 {
				Warn("%s handling time exceeded %f secs for msg_id %d op-code: %d", c.RemoteAddress(), timeSpentInHandler, m.MessageID(), m.MessageCode())
			}
		}()

		if fe := handler(m, c); fe != nil {
			Debug("error handling message opcode: %d, remote address %s\n %s", m.MessageCode(), c.RemoteAddress(), fe.Error())
		}
	}

	if c.handlers != nil && len(c.handlers) > 0 {
		if v, ok := c.handlers[m.MessageCode()]; ok {
			invokeHandlerWrapper(v)
			return
		}
	} else {
		if c.onMessageReceived != nil {
			c.onMessageReceived(c, m, sizeInBytes)
		}
	}
}
